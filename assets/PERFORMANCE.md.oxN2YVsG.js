import{_ as t,c as a,o as n,ag as r}from"./chunks/framework.D7F4Kr4v.js";const h=JSON.parse('{"title":"Performance Benchmarks","description":"","frontmatter":{},"headers":[],"relativePath":"PERFORMANCE.md","filePath":"PERFORMANCE.md","lastUpdated":1771056337000}'),i={name:"PERFORMANCE.md"};function o(s,e,l,c,d,g){return n(),a("div",null,[...e[0]||(e[0]=[r('<h1 id="performance-benchmarks" tabindex="-1">Performance Benchmarks <a class="header-anchor" href="#performance-benchmarks" aria-label="Permalink to &quot;Performance Benchmarks&quot;">​</a></h1><p>This document describes the performance characteristics of the Native Content Relationships Integrity Engine under large-scale datasets. All benchmarks were performed using deterministic test datasets and SQL-native validation logic.</p><h2 id="test-environment" tabindex="-1">Test Environment <a class="header-anchor" href="#test-environment" aria-label="Permalink to &quot;Test Environment&quot;">​</a></h2><ul><li><strong>Dataset Size</strong>: 100,000 – 1,000,000 relationship rows</li><li><strong>Storage Engine</strong>: InnoDB</li><li><strong>Indexing</strong>: Composite covering index (<code>type_lookup</code>)</li><li><strong>WordPress</strong>: 6.x</li><li><strong>PHP</strong>: 7.4+</li><li><strong>Object Cache</strong>: Disabled (baseline measurement)</li><li><strong>MySQL Buffer Pool</strong>: Warmed before final run</li></ul><h2 id="latency-metrics" tabindex="-1">Latency Metrics <a class="header-anchor" href="#latency-metrics" aria-label="Permalink to &quot;Latency Metrics&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">Operation</th><th style="text-align:left;">100k Rows</th><th style="text-align:left;">1.0M Rows</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Point Lookup (Mean)</strong></td><td style="text-align:left;">0.49 ms</td><td style="text-align:left;">1.00 ms</td></tr><tr><td style="text-align:left;"><strong>Point Lookup (P95)</strong></td><td style="text-align:left;">0.85 ms</td><td style="text-align:left;">2.73 ms</td></tr><tr><td style="text-align:left;"><strong>Covering Index Mean</strong></td><td style="text-align:left;">0.22 ms</td><td style="text-align:left;">0.61 ms</td></tr><tr><td style="text-align:left;"><strong>Covering Index P95</strong></td><td style="text-align:left;">1.25 ms</td><td style="text-align:left;">3.42 ms</td></tr><tr><td style="text-align:left;"><strong>Full Graph Scan</strong></td><td style="text-align:left;">~7.2 s</td><td style="text-align:left;">~64.2 s</td></tr></tbody></table><p><em>* Variation depends on buffer pool state and cache warm-up.</em></p><h2 id="resource-efficiency" tabindex="-1">Resource Efficiency <a class="header-anchor" href="#resource-efficiency" aria-label="Permalink to &quot;Resource Efficiency&quot;">​</a></h2><h3 id="memory-management" tabindex="-1">Memory Management <a class="header-anchor" href="#memory-management" aria-label="Permalink to &quot;Memory Management&quot;">​</a></h3><p>The Integrity Engine uses chunked processing with bounded iteration to ensure stability regardless of dataset size.</p><ul><li><strong>Peak Memory Delta (1.0M rows)</strong>: ~2.21 MB</li><li><strong>Maximum Observed Memory Usage</strong>: &lt; 5 MB</li><li><strong>Scaling Factor</strong>: Independent of dataset size</li></ul><p>This ensures compatibility with shared hosting and restricted enterprise environments.</p><h3 id="database-optimization-strategy" tabindex="-1">Database Optimization Strategy <a class="header-anchor" href="#database-optimization-strategy" aria-label="Permalink to &quot;Database Optimization Strategy&quot;">​</a></h3><p>The schema utilizes a composite covering index to maximize throughput: <code>KEY type_lookup (type, from_id, to_id)</code></p><p>This enables:</p><ul><li><strong>Index-only lookups</strong> for common queries.</li><li><strong>Avoidance of full table scans</strong> during integrity audits.</li><li><strong>Stable query time growth</strong> ($O(\\log n)$).</li></ul><p>Under realistic workloads, query latency remains sub-2ms even at 1M rows.</p><h2 id="scaling-characteristics" tabindex="-1">Scaling Characteristics <a class="header-anchor" href="#scaling-characteristics" aria-label="Permalink to &quot;Scaling Characteristics&quot;">​</a></h2><p>Observed complexity classes:</p><ul><li><strong>Point Lookups</strong>: $O(\\log n)$</li><li><strong>Constraint Checks</strong>: $O(\\log n)$</li><li><strong>Integrity Scan</strong>: $O(n)$ (chunked, bounded memory)</li></ul><p><strong>Projected performance at 10M rows:</strong></p><ul><li>Point lookups remain index-bound.</li><li>Full graph scan expected in ~10–12 minutes (linear scaling).</li><li>Memory usage remains bounded (&lt; 5MB).</li></ul><h2 id="benchmark-methodology" tabindex="-1">Benchmark Methodology <a class="header-anchor" href="#benchmark-methodology" aria-label="Permalink to &quot;Benchmark Methodology&quot;">​</a></h2><p>Benchmarks are executed via the <code>benchmarks/performance-report.php</code> utility. The methodology involves:</p><ol><li><strong>Deterministic Data Generation</strong>: Creating predictable relationship graphs.</li><li><strong>Buffer Pool Warming</strong>: Executing primer queries before final measurement.</li><li><strong>Mean Latency Calculation</strong>: Averaging results over multiple iterations.</li><li><strong>Memory Delta Tracking</strong>: Reporting peak usage via <code>memory_get_peak_usage()</code>.</li></ol><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>For enterprise environments requiring high-availability, we recommend monitoring $P95$ query latency during full integrity scans.</p></div>',26)])])}const u=t(i,[["render",o]]);export{h as __pageData,u as default};
